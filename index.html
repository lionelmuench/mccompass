<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#000000" />
  <title>McCompass</title>
  <style>
    :root {
      --bg: #0b0b0c;
      --fg: #f6f7fb;
      --muted: #a7acb7;
      --accent: #ffcc00; /* golden arches vibes */
      --card: #121216;
      --ok: #16a34a;
      --warn: #ca8a04;
      --err: #ef4444;
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 800px at 80% -20%, #1a1b20 0%, #0b0b0c 60%);
      color: var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .wrap {
      min-height: 100%;
      display: grid;
      grid-template-rows: auto 1fr auto;
    }
    header, footer { padding: 12px 16px; }
    header { display:flex; align-items:center; gap: 10px; }
    header h1 { font-size: 18px; margin: 0; font-weight: 700; letter-spacing: .3px; }
    header .dot { width: 8px; height: 8px; border-radius: 9999px; background: var(--err); box-shadow: 0 0 0 2px #0003; }
    header .ok { background: var(--ok);} header .warn { background: var(--warn);} header .err { background: var(--err);} 

    main { display:grid; place-items:center; padding: 16px; }
    .card {
      width: min(560px, 92vw);
      background: linear-gradient(180deg, #14151a, #0e0f13);
      border: 1px solid #23242c;
      border-radius: 20px;
      padding: 18px 18px 22px;
      box-shadow: 0 10px 30px #0008, inset 0 1px 0 #ffffff07;
    }
    .status { font-size: 12px; color: var(--muted); margin-bottom: 12px; }
    .row { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
    .row > * { flex: 1 1 auto; }

    button.primary {
      appearance: none;
      border: 0;
      border-radius: 14px;
      padding: 14px 16px;
      background: var(--accent);
      color: #1a1a1a;
      font-weight: 800;
      font-size: 16px;
      cursor: pointer;
      box-shadow: 0 6px 20px #ffcc0044, inset 0 1px 0 #fff8;
    }
    button.secondary {
      appearance: none;
      border: 1px solid #2a2c36;
      border-radius: 14px;
      padding: 12px 14px;
      background: #171820;
      color: var(--fg);
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
    }
    button:disabled { opacity: .6; cursor: not-allowed; }

    .compass {
      margin: 12px 0 16px;
      display: grid; place-items: center;
    }
    .dial {
      width: min(75vw, 420px);
      aspect-ratio: 1/1;
      border-radius: 50%;
      background: conic-gradient(from 0deg, #1d1e26 0 25%, #161720 0 50%, #1d1e26 0 75%, #161720 0);
      border: 1px solid #2a2c36;
      box-shadow: inset 0 0 0 2px #ffffff06, 0 10px 30px #0007;
      position: relative;
    }
    .tick {
      position: absolute; inset: 10px; border-radius: 50%; pointer-events: none;
      background: repeating-conic-gradient(#ffffff10 0deg 1deg, transparent 1deg 3deg);
    }
    .arrow {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(0deg);
      width: 0; height: 0;
      border-left: 20px solid transparent;
      border-right: 20px solid transparent;
      border-bottom: 110px solid var(--accent);
      filter: drop-shadow(0 8px 16px #ffcc0030);
      transform-origin: 50% 80%;
    }
    .center-dot { position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); width: 12px; height: 12px; border-radius: 9999px; background:#ffe27a; box-shadow: 0 0 0 4px #0005; }

    .metrics { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .kpi { background:#12131a; border:1px solid #23242c; border-radius: 14px; padding: 12px; }
    .kpi .label { font-size: 12px; color: var(--muted); }
    .kpi .value { font-size: 20px; font-weight: 800; margin-top: 4px; }

    .help { color: var(--muted); font-size: 12px; line-height: 1.4; margin-top: 12px; }
    a { color: #93c5fd; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="dot err" id="status-dot"></div>
      <h1>McCompass</h1>
    </header>

    <main>
      <section class="card">
        <div class="status" id="status">Tap Enable to grant motion + location access.</div>
        <div class="row" style="margin-bottom:10px;">
          <button class="primary" id="enableBtn">Enable Compass</button>
          <button class="secondary" id="recenterBtn" disabled>Recenter</button>
        </div>

        <div class="compass">
          <div class="dial" id="dial">
            <div class="tick"></div>
            <div class="arrow" id="arrow"></div>
            <div class="center-dot"></div>
          </div>
        </div>

        <div class="metrics">
          <div class="kpi"><div class="label">Nearest McDonald's</div><div class="value" id="storeName">—</div></div>
          <div class="kpi"><div class="label">Distance</div><div class="value" id="distance">—</div></div>
          <div class="kpi"><div class="label">Bearing to Store</div><div class="value" id="bearing">—</div></div>
          <div class="kpi"><div class="label">Your Heading</div><div class="value" id="heading">—</div></div>
        </div>

        <p class="help">
          Works best outdoors, phone flat and in portrait. Requires HTTPS (GitHub Pages is fine). On iPhone, iOS will prompt for Motion & Orientation access when you tap Enable. If heading seems off, move the phone in a figure‑8 to recalibrate.
        </p>
        <p class="help">
          Data file: <code>mcdonalds.json</code> in the same folder (CORS-allowed). Format: <code>[{ "name": "McDonald's — Main St", "lat": 40.7128, "lon": -74.0060 }, ...]</code>.
        </p>
      </section>
    </main>

    <footer>
      <small style="color:var(--muted);">Client‑side only. No tracking. <span id="debug"></span></small>
    </footer>
  </div>

  <script>
    // ---- Utilities ----
    const toRad = d => d * Math.PI / 180;
    const toDeg = r => r * 180 / Math.PI;
    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371e3; // meters
      const φ1 = toRad(lat1), φ2 = toRad(lat2);
      const Δφ = toRad(lat2 - lat1); const Δλ = toRad(lon2 - lon1);
      const a = Math.sin(Δφ/2)**2 + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ/2)**2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c; // meters
    }
    function initialBearing(lat1, lon1, lat2, lon2) {
      const φ1 = toRad(lat1), φ2 = toRad(lat2); const λ1 = toRad(lon1), λ2 = toRad(lon2);
      const y = Math.sin(λ2-λ1) * Math.cos(φ2);
      const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(λ2-λ1);
      const θ = Math.atan2(y, x);
      return (toDeg(θ) + 360) % 360; // degrees
    }

    // Compute heading from DeviceOrientation (alpha/beta/gamma) – cross-platform
    // Based on common approach to derive compass heading from Euler rotations
    function computeHeadingFromEuler(alpha, beta, gamma) {
      // Convert to radians
      const α = toRad(alpha); const β = toRad(beta); const γ = toRad(gamma);
      // Formula to compute compass heading
      const cA = Math.cos(α), sA = Math.sin(α);
      const sB = Math.sin(β), cB = Math.cos(β);
      const sG = Math.sin(γ), cG = Math.cos(γ);
      // Calculate A, B, C rotation components
      const rA = - cA * sG - sA * sB * cG;
      const rB = - sA * sG + cA * sB * cG;
      let heading = Math.atan2(rA, rB);
      heading = heading < 0 ? heading + 2*Math.PI : heading;
      return toDeg(heading); // 0..360
    }

    // Simple low-pass filter for smoother UI
    function smooth(prev, next, factor = 0.15) {
      if (prev == null || Number.isNaN(prev)) return next;
      let delta = ((next - prev + 540) % 360) - 180; // shortest path
      return (prev + factor * delta + 360) % 360;
    }

    // ---- App State ----
    const state = {
      enabled: false,
      user: { lat: null, lon: null, heading: null },
      target: { name: null, lat: null, lon: null, distance: null, bearing: null },
      stores: [],
      lastUpdate: 0
    };

    // ---- Elements ----
    const el = {
      status: document.getElementById('status'),
      statusDot: document.getElementById('status-dot'),
      enableBtn: document.getElementById('enableBtn'),
      recenterBtn: document.getElementById('recenterBtn'),
      arrow: document.getElementById('arrow'),
      storeName: document.getElementById('storeName'),
      distance: document.getElementById('distance'),
      bearing: document.getElementById('bearing'),
      heading: document.getElementById('heading'),
      debug: document.getElementById('debug')
    };

    function setStatus(text, level='warn') {
      el.status.textContent = text;
      el.statusDot.classList.remove('ok','warn','err');
      el.statusDot.classList.add(level);
    }

    function formatDistance(meters) {
      if (meters == null) return '—';
      if (meters < 1000) return `${Math.round(meters)} m`;
      const km = meters / 1000;
      return `${km.toFixed(km < 10 ? 2 : 1)} km`;
    }

    function rotateArrow(toDegrees) {
      el.arrow.style.transform = `translate(-50%, -50%) rotate(${toDegrees.toFixed(1)}deg)`;
    }

    function updateMetrics() {
      el.storeName.textContent = state.target.name ?? '—';
      el.distance.textContent = formatDistance(state.target.distance);
      el.bearing.textContent = state.target.bearing != null ? `${state.target.bearing.toFixed(0)}°` : '—';
      el.heading.textContent = state.user.heading != null ? `${state.user.heading.toFixed(0)}°` : '—';
    }

    function chooseNearest(lat, lon) {
      if (!state.stores.length) return null;
      let best = null; let bestD = Infinity;
      for (const s of state.stores) {
        const d = haversine(lat, lon, s.lat, s.lon);
        if (d < bestD) { bestD = d; best = s; }
      }
      return { ...best, distance: bestD };
    }

    function recalcTarget() {
      const { lat, lon } = state.user;
      if (lat == null || lon == null) return;
      const nearest = chooseNearest(lat, lon);
      if (!nearest) return;
      const bearing = initialBearing(lat, lon, nearest.lat, nearest.lon);
      state.target = { name: nearest.name || "Nearest", lat: nearest.lat, lon: nearest.lon, distance: nearest.distance, bearing };
      updateMetrics();
    }

    function renderArrow() {
      const h = state.user.heading;
      const b = state.target.bearing;
      if (h == null || b == null) return;
      const relative = ((b - h + 540) % 360) - 180; // -180..180, 0 means you're pointing at it
      const arrowDeg = relative; // arrow points relative to your top
      rotateArrow(arrowDeg);
    }

    // ---- Permissions ----
    async function requestMotionPermissionIfNeeded() {
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
      // iOS 13+ requires an explicit permission call for motion/orientation
      const DevOrient = window.DeviceOrientationEvent;
      const DevMotion = window.DeviceMotionEvent;
      try {
        if (isIOS && DevOrient && typeof DevOrient.requestPermission === 'function') {
          const resp = await DevOrient.requestPermission();
          if (resp !== 'granted') throw new Error('Motion permission denied');
        }
        if (isIOS && DevMotion && typeof DevMotion.requestPermission === 'function') {
          // Some iOS versions gate this separately
          try { await DevMotion.requestPermission(); } catch {}
        }
        return true;
      } catch (e) {
        setStatus('Motion permission denied. Open Settings → Safari → Motion & Orientation Access.', 'err');
        return false;
      }
    }

    function requestGeo() {
      return new Promise((resolve, reject) => {
        if (!('geolocation' in navigator)) return reject(new Error('Geolocation unsupported'));
        navigator.geolocation.getCurrentPosition(pos => {
          const { latitude, longitude } = pos.coords;
          state.user.lat = latitude; state.user.lon = longitude;
          recalcTarget();
          resolve(pos);
        }, err => reject(err), { enableHighAccuracy: true, timeout: 10000, maximumAge: 5000 });
      });
    }

    // ---- Sensors ----
    function onDeviceOrientation(e) {
      let heading;
      if (typeof e.webkitCompassHeading === 'number' && !isNaN(e.webkitCompassHeading)) {
        // iOS Safari provides absolute heading directly
        heading = e.webkitCompassHeading; // 0 = North
      } else if (e.absolute === true && typeof e.alpha === 'number') {
        // Use Euler -> compass heading computation
        heading = computeHeadingFromEuler(e.alpha, e.beta || 0, e.gamma || 0);
      } else if (typeof e.alpha === 'number') {
        // Fallback
        heading = (360 - e.alpha) % 360;
      }
      if (typeof heading === 'number' && !isNaN(heading)) {
        state.user.heading = smooth(state.user.heading, heading);
        renderArrow();
        updateMetrics();
        el.recenterBtn.disabled = false;
        setStatus('Compass active', 'ok');
      }
    }

    function startOrientation() {
      window.addEventListener('deviceorientation', onDeviceOrientation, true);
    }

    // ---- Dataset ----
    async function loadStores() {
      try {
        const res = await fetch('mcdonalds.json', { cache: 'no-store' });
        if (!res.ok) throw new Error(res.status + ' ' + res.statusText);
        const data = await res.json();
        // Normalize keys
        state.stores = data.map((d, i) => ({ name: d.name || `McD #${i+1}` , lat: +d.lat || +d.latitude, lon: +d.lon || +d.lng || +d.longitude } )).filter(d => isFinite(d.lat) && isFinite(d.lon));
        if (!state.stores.length) throw new Error('Empty dataset');
      } catch (e) {
        setStatus('Failed to load mcdonalds.json. Using a tiny built-in sample.', 'warn');
        state.stores = [
          { name: "McDonald's – Times Sq", lat: 40.7580, lon: -73.9855 },
          { name: "McDonald's – Union Sq", lat: 40.7359, lon: -73.9911 },
          { name: "McDonald's – 34th St", lat: 40.7505, lon: -73.9934 }
        ];
      }
    }

    // ---- Controls ----
    el.enableBtn.addEventListener('click', async () => {
      el.enableBtn.disabled = true;
      try {
        await loadStores();
        const motionOK = await requestMotionPermissionIfNeeded();
        const geo = await requestGeo();
        if (motionOK) startOrientation();
        setStatus('Ready. Point the arrow at the arches.', 'ok');
        state.enabled = true;
      } catch (e) {
        console.error(e);
        setStatus('Unable to start: ' + (e.message || e), 'err');
        el.enableBtn.disabled = false;
      }
    });

    el.recenterBtn.addEventListener('click', async () => {
      try {
        await requestGeo();
        recalcTarget();
        renderArrow();
      } catch (e) {
        setStatus('Recenter failed: ' + (e.message || e), 'err');
      }
    });

    // Keep nearest store updated as we move
    if ('geolocation' in navigator) {
      navigator.geolocation.watchPosition(pos => {
        const { latitude, longitude } = pos.coords;
        state.user.lat = latitude; state.user.lon = longitude;
        recalcTarget();
        renderArrow();
      }, err => {
        // ignore frequent watch errors
      }, { enableHighAccuracy: true, maximumAge: 3000, timeout: 10000 });
    }

    // Debug orientation type
    el.debug.textContent = `UA: ${navigator.userAgent}`;
  </script>
</body>
</html>
